---
id: intro20
title: '💜20.JsHandle'
---

# Playwright for Python：JSHandle 类中文版文档
JSHandle 类用于表示浏览器 JavaScript 环境中的对象（如 DOM 元素、普通对象、数组、函数等），是 Python 代码与浏览器端 JS 对象之间的「桥梁」。通过 JSHandle，你可以在 Python 中持有、操作浏览器端的 JS 对象，获取其属性或调用其方法，实现跨环境的数据交互和操作。

## 快速示例
### 同步示例（创建并操作 JS 对象）
```python
from playwright.sync_api import sync_playwright, Playwright

def run(playwright: Playwright):
    browser = playwright.chromium.launch(headless=False)
    context = browser.new_context()
    page = context.new_page()
    page.goto("https://example.com")

    # 1. 在浏览器中创建 JS 对象，返回 JSHandle 实例
    js_handle = page.evaluate_handle("""() => {
        return {
            name: "Playwright",
            version: "1.45.0",
            getInfo: function() {
                return `${this.name} v${this.version}`;
            }
        };
    }""")

    # 2. 获取 JS 对象的属性（通过 handle 获取）
    name_handle = js_handle.get_property("name")
    print("JS对象名称：", name_handle.json_value())  # 输出：Playwright

    # 3. 调用 JS 对象的方法
    info_handle = js_handle.evaluate_handle("obj => obj.getInfo()")
    print("JS对象信息：", info_handle.json_value())  # 输出：Playwright v1.45.0

    # 4. 直接转换 JS 对象为 Python 字典
    js_obj_dict = js_handle.json_value()
    print("Python 格式的 JS 对象：", js_obj_dict)  # 输出：{'name': 'Playwright', 'version': '1.45.0'}

    # 5. 释放 JSHandle（避免内存泄漏）
    js_handle.dispose()
    name_handle.dispose()
    info_handle.dispose()

    browser.close()

with sync_playwright() as playwright:
    run(playwright)
```

### 异步示例（操作 DOM 元素对应的 JSHandle）
```python
import asyncio
from playwright.async_api import async_playwright, Playwright

async def run(playwright: Playwright):
    browser = await playwright.firefox.launch()
    context = await browser.new_context()
    page = await context.new_page()
    await page.goto("https://example.com")

    # 1. 获取 DOM 元素对应的 JSHandle（ElementHandle 是 JSHandle 的子类）
    h1_handle = await page.query_selector_handle("h1")

    # 2. 通过 JSHandle 获取元素文本
    text_handle = await h1_handle.evaluate_handle("el => el.textContent")
    print("H1 元素文本：", await text_handle.json_value())

    # 3. 修改元素样式
    await h1_handle.evaluate("el => el.style.color = 'red'")

    # 4. 释放资源
    await h1_handle.dispose()
    await text_handle.dispose()

    await browser.close()

async def main():
    async with async_playwright() as playwright:
        await run(playwright)

asyncio.run(main())
```

## 核心说明：JSHandle 与 ElementHandle 的关系
`ElementHandle` 是 `JSHandle` 的**子类**，专门用于表示浏览器中的 DOM 元素对象，继承了 JSHandle 的所有方法，并扩展了 DOM 元素特有的操作（如点击、填充等）。

| 类型          | 用途                          | 专属特性                          |
|---------------|-------------------------------|-----------------------------------|
| `JSHandle`    | 表示通用 JS 对象（普通对象、数组、函数等） | 通用对象操作（获取属性、调用方法） |
| `ElementHandle` | 表示 DOM 元素对象              | 包含 click、fill 等 DOM 操作方法  |

## JSHandle 类核心方法
### 1. dispose
#### 功能描述
释放当前 JSHandle 所持有的浏览器端 JS 对象，释放内存资源，避免浏览器内存泄漏。**所有手动创建的 JSHandle 都应在使用完毕后调用该方法**。

#### 用法示例
```python
# 同步
js_handle = page.evaluate_handle("() => ({ a: 1, b: 2 })")
# 使用完毕后释放
js_handle.dispose()

# 异步
js_handle = await page.evaluate_handle("() => ({ a: 1, b: 2 })")
await js_handle.dispose()
```

### 2. evaluate
#### 功能描述
在浏览器上下文执行指定的 JavaScript 函数，将当前 JSHandle 作为第一个参数传入函数，支持传递额外参数，返回函数执行结果（直接转换为 Python 类型）。

#### 用法示例
```python
# 同步：调用 JS 对象的方法并获取结果
js_handle = page.evaluate_handle("() => ({ x: 10, y: 20, sum: function() { return this.x + this.y; } })")
# 将 js_handle 作为第一个参数传入，执行 sum 方法
result = js_handle.evaluate("obj => obj.sum()")
print("求和结果：", result)  # 输出：30

# 传递额外参数
result = js_handle.evaluate("(obj, multiplier) => (obj.x + obj.y) * multiplier", 3)
print("求和后乘以3：", result)  # 输出：90

# 异步
js_handle = await page.evaluate_handle("() => ({ x: 10, y: 20 })")
result = await js_handle.evaluate("(obj, multiplier) => (obj.x + obj.y) * multiplier", 3)
print(result)  # 输出：90
```

#### 参数说明
- `expression`：JavaScript 函数或表达式（字符串格式），当前 JSHandle 会作为第一个参数。
- `arg`（可选）：传递给 JavaScript 函数的额外参数（支持 Python 基础类型，会自动转换为 JS 类型）。

#### 返回值
Python 类型的数据（如字典、列表、数字、字符串等），对应 JavaScript 函数的返回结果。

### 3. evaluate_handle
#### 功能描述
与 `evaluate` 类似，在浏览器上下文执行 JavaScript 函数，将当前 JSHandle 作为第一个参数传入，但**返回结果为 JSHandle 实例**（而非直接转换为 Python 类型），适用于需要继续操作返回的 JS 对象的场景。

#### 用法示例
```python
# 同步：获取 JS 对象的属性（返回新的 JSHandle）
js_handle = page.evaluate_handle("() => ({ user: { name: 'Tom', age: 20 } })")
# 获取 user 属性对应的 JSHandle
user_handle = js_handle.evaluate_handle("obj => obj.user")
# 再获取 user 的 name 属性
name_handle = user_handle.evaluate_handle("user => user.name")
print("用户名：", name_handle.json_value())  # 输出：Tom

# 异步
js_handle = await page.evaluate_handle("() => ({ user: { name: 'Tom', age: 20 } })")
user_handle = await js_handle.evaluate_handle("obj => obj.user")
name_handle = await user_handle.evaluate_handle("user => user.name")
print(await name_handle.json_value())  # 输出：Tom
```

#### 参数说明
与 `evaluate` 方法一致。

#### 返回值
`JSHandle` 实例（若返回的是 DOM 元素，则返回 `ElementHandle` 实例）。

### 4. get_property
#### 功能描述
获取当前 JSHandle 对应 JS 对象的指定属性值，返回该属性对应的 `JSHandle` 实例，适用于直接获取对象属性的场景（比 `evaluate_handle` 更简洁）。

#### 用法示例
```python
# 同步
js_handle = page.evaluate_handle("() => ({ title: 'Playwright Docs', author: 'Microsoft' })")
# 获取 title 属性
title_handle = js_handle.get_property("title")
print("标题：", title_handle.json_value())  # 输出：Playwright Docs
# 获取 author 属性
author_handle = js_handle.get_property("author")
print("作者：", author_handle.json_value())  # 输出：Microsoft

# 异步
js_handle = await page.evaluate_handle("() => ({ title: 'Playwright Docs' })")
title_handle = await js_handle.get_property("title")
print(await title_handle.json_value())  # 输出：Playwright Docs
```

#### 参数说明
- `name`：JS 对象的属性名称（字符串）。

#### 返回值
`JSHandle` 实例（属性值对应的 JSHandle）。

### 5. json_value
#### 功能描述
将当前 JSHandle 对应 JS 对象转换为 Python 可序列化的数据类型（如字典、列表、字符串、数字等），实现浏览器 JS 对象到 Python 数据的转换。

#### 用法示例
```python
# 同步
# 普通对象转换
js_handle = page.evaluate_handle("() => ({ a: 1, b: [2, 3], c: 'hello' })")
python_data = js_handle.json_value()
print("Python 数据：", python_data)  # 输出：{'a': 1, 'b': [2, 3], 'c': 'hello'}
print("数据类型：", type(python_data))  # 输出：<class 'dict'>

# 数组转换
array_handle = page.evaluate_handle("() => [10, 20, 30]")
python_array = array_handle.json_value()
print("Python 数组：", python_array)  # 输出：[10, 20, 30]

# 异步
js_handle = await page.evaluate_handle("() => ({ a: 1, b: [2, 3] })")
python_data = await js_handle.json_value()
print(python_data)  # 输出：{'a': 1, 'b': [2, 3]}
```

#### 注意事项
- 仅支持可序列化的 JS 对象（如普通对象、数组、基本类型），无法序列化函数、DOM 元素等特殊对象（会返回 `None` 或序列化失败）。
- 对于大型 JS 对象，转换可能存在性能开销，建议按需获取属性而非整体转换。

## 常见场景实战
### 场景 1：操作浏览器端的全局变量
```python
# 同步
def test_global_variable(page):
    # 1. 设置全局变量
    page.evaluate("window.globalConfig = { env: 'test', timeout: 5000 }")
    # 2. 获取全局变量对应的 JSHandle
    global_config_handle = page.evaluate_handle("() => window.globalConfig")
    # 3. 获取全局变量的属性
    env_handle = global_config_handle.get_property("env")
    timeout_handle = global_config_handle.get_property("timeout")
    print(f"环境：{env_handle.json_value()}")  # 输出：test
    print(f"超时时间：{timeout_handle.json_value()}")  # 输出：5000
    # 4. 释放资源
    global_config_handle.dispose()
    env_handle.dispose()
    timeout_handle.dispose()

# 异步
async def test_global_variable(page):
    await page.evaluate("window.globalConfig = { env: 'test', timeout: 5000 }")
    global_config_handle = await page.evaluate_handle("() => window.globalConfig")
    env_handle = await global_config_handle.get_property("env")
    print(await env_handle.json_value())
    await global_config_handle.dispose()
    await env_handle.dispose()
```

### 场景 2：批量获取 JS 对象的多个属性
```python
# 同步
def get_multiple_properties(page):
    js_handle = page.evaluate_handle("""() => ({
        product: "Laptop",
        price: 9999,
        stock: 50,
        specs: { cpu: "i7", ram: "16GB" }
    })""")

    # 批量获取属性
    properties = ["product", "price", "stock", "specs"]
    property_dict = {}
    for prop in properties:
        prop_handle = js_handle.get_property(prop)
        property_dict[prop] = prop_handle.json_value()
        prop_handle.dispose()

    print("批量属性结果：", property_dict)
    # 输出：{'product': 'Laptop', 'price': 9999, 'stock': 50, 'specs': {'cpu': 'i7', 'ram': '16GB'}}
    js_handle.dispose()

# 异步
async def get_multiple_properties(page):
    js_handle = await page.evaluate_handle("""() => ({
        product: "Laptop",
        price: 9999
    })""")
    properties = ["product", "price"]
    property_dict = {}
    for prop in properties:
        prop_handle = await js_handle.get_property(prop)
        property_dict[prop] = await prop_handle.json_value()
        await prop_handle.dispose()
    print(property_dict)
    await js_handle.dispose()
```

### 场景 3：调用 JS 函数并传递复杂参数
```python
# 同步
def call_js_function_with_params(page):
    # 创建 JS 函数对应的 Handle
    func_handle = page.evaluate_handle("""() => {
        return function(userInfo, scores) {
            return {
                username: userInfo.name,
                totalScore: scores.reduce((a, b) => a + b, 0),
                average: scores.reduce((a, b) => a + b, 0) / scores.length
            };
        };
    }""")

    # 准备 Python 复杂参数
    user_info = {"name": "Alice", "age": 25}
    scores = [85, 90, 95, 88]

    # 调用 JS 函数
    result_handle = func_handle.evaluate_handle("(func, u, s) => func(u, s)", user_info, scores)
    result = result_handle.json_value()

    print("函数执行结果：", result)
    # 输出：{'username': 'Alice', 'totalScore': 358, 'average': 89.5}

    # 释放资源
    func_handle.dispose()
    result_handle.dispose()

# 异步
async def call_js_function_with_params(page):
    func_handle = await page.evaluate_handle("""() => {
        return function(userInfo, scores) {
            return { totalScore: scores.reduce((a, b) => a + b, 0) };
        };
    }""")
    user_info = {"name": "Alice"}
    scores = [85, 90]
    result_handle = await func_handle.evaluate_handle("(func, u, s) => func(u, s)", user_info, scores)
    result = await result_handle.json_value()
    print(result)
    await func_handle.dispose()
    await result_handle.dispose()
```

## 重要说明
1.  **内存管理**：JSHandle 会持有浏览器端的内存资源，手动创建的 JSHandle 必须通过 `dispose()` 释放，否则会导致浏览器内存泄漏（尤其是在循环创建 JSHandle 的场景）。
2.  **序列化限制**：`json_value()` 仅支持可序列化的 JS 对象，对于函数、Symbol、DOM 元素等不可序列化对象，会返回 `None` 或不完整数据。
3.  **优先使用 Locator**：对于 DOM 元素操作，Playwright 推荐使用 `Locator` 而非 `ElementHandle`（JSHandle 子类），Locator 具有自动重连特性，更稳定可靠。
4.  **跨环境转换**：Python 与 JS 之间的参数传递会自动进行类型转换（如 Python 字典 → JS 对象、Python 列表 → JS 数组），但不支持复杂自定义类型。
5.  **异步注意事项**：异步模式下，所有 JSHandle 方法（如 `dispose()`、`get_property()`）都需要添加 `await` 关键字。

---

要不要我帮你整理 **JSHandle 与 Locator 对比使用指南**，明确两种方式的适用场景，以及如何从 ElementHandle 平滑迁移到 Locator？
